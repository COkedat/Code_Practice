"""사실 이 화살표 연산자는 전위 감소 연산자(prefix decrement operator, --x)를 이용한 농담으로, 0 <-- x은 --x > 0을 화살표처럼 보이도록 눈속임한 것이다. 따라서 첫 번째 코드의 반복문은 아래와 같이 동작한다.

x의 값을 1 감소시킨다.
만약 x의 값이 0보다 크지 않다면 프로그램을 종료한다.
x의 값을 출력하고 처음으로 돌아간다.
감소 연산자는 아래와 같은 특징이 있다.

-가 여러 개 연속되어 있을 때는 반드시 앞에서부터 두 개씩 끊어서 해석된다. 예를 들어 ------x는 -- - -- -x 또는 - -- - --x 등이 아니라 반드시 -- -- --x로 해석된다.
감소 연산자는 단항 부정 연산자(unary minus operator, -x)가 적용된 식에는 적용할 수 없다. 예를 들어 -----x는 -- -- -x로 해석되고, 감소 연산자가 -x에 적용되었으므로 컴파일에 실패한다.
두 번째 코드의 0 <---- x는 -- --x > 0과 같고, 감소 연산자가 두 번 적용되었으므로 x의 값이 한번에 2씩 줄어든다.

위의 코드에서 x의 초기값과 화살표의 길이를 바꿨을 때, 몇 개의 수가 출력될지 예상해 보자.

입력
첫 줄에 변수 x의 초기값을 뜻하는 정수 X와 화살표의 길이를 뜻하는 정수 N(-100 ≤ X ≤ 100, 0 ≤ N ≤ 10)이 주어진다.

출력
첫째 줄에 프로그램의 실행 결과를 출력한다.

만약 프로그램이 정상적으로 종료된다면 프로그램이 출력한 수의 개수를 출력한다.
만약 프로그램이 무한히 많은 수를 출력한다면 INFINITE를 출력한다.
만약 프로그램이 지문에 주어진 조건에 의해 컴파일에 실패할 경우 ERROR를 출력한다. 

#include <iostream>

int main(){
  int x = 10;

  while( 0 <-- x ){
    std::cout << x << std::endl;
  }
  return 0;
}

"""
def countWhile(X, N):
    cnt=0
    X-=(N//2)
    while(0 < X):
        cnt+=1
        X-=(N//2)
    return cnt

# 정수 x, 화살표의 길이 정수 N (-100 ≤ X ≤ 100, 0 ≤ N ≤ 10)
x = list(map(int, input().split(" ")))
X, N = x[0], x[1]
# 길이가 1일때
if(N==1):
    # X가 음수라면 (무한에 빠짐)
    if(X < 0): 
        print("INFINITE")
    # X가 양수라면 (음수로 변경)
    else: 
        print(countWhile(-X, 0))
elif( N%2 != 0 ): # -가 1이 아닌홀수일 경우 (오류남)
    print("ERROR")
elif ((X>0 and N==0)): # 증감이 없으면서 양수일 경우 (무한에 빠짐)
    print("INFINITE")
else: # 그외의 경우 (정상 진행)
    print(countWhile(X, N))




